# algorithms.py
def modular_exponentiation(a, x, p):
    """Возведение в степень по модулю. Бинарное возведение в степень
    https://www.youtube.com/watch?v=2V_zU4DNdvU&ab_channel=IgorMamay 
        Параметры:
        a - основание степени
        x - показатель степени (целое неотрицательное число)
        p - модуль, по которому берется остаток
        
    Алгоритм эффективен и работает за O(log(x)) операций."""
    result = 1
    while x > 0:
        if x % 2 == 1:  # Если x нечетное
            result = (result * a) % p
        a = (a * a) % p
        x //= 2  # Делим x на 2
    return result

def gcd_extended(a, b): 
    """
    Обобщенный алгоритм Евклида для нахождения НОД и коэффициентов x и y,
    удовлетворяющих уравнению: a * x + b * y = gcd(a, b)
    """
    # Инициализируем два списка (вектора) с информацией:
    # Первый элемент списка – текущее значение (остаток) числа,
    # Второй и третий – коэффициенты для a и b соответственно.
    U = [a, 1, 0]  # Изначально: остаток = a, коэффициенты: x=1, y=0
    V = [b, 0, 1]  # Изначально: остаток = b, коэффициенты: x=0, y=1

    while V[0] != 0:
        # Вычисляем целочисленное частное деления текущего остатка U[0] на V[0]
        q = U[0] // V[0]
        # Обновляем векторы:
        # Новое значение U принимает значение текущего V.
        # Новый V вычисляется поэлементно:
        #   для каждого i от 0 до 2 (остаток и оба коэффициента)
        #   вычисляем разницу: старый U[i] минус q, умноженное на V[i]
        U, V = V, [U[i] - q * V[i] for i in range(0, 3)]
    # Когда V[0] станет 0, алгоритм завершает работу.
    return U[0], U[1], U[2]  # Возвращаем: (НОД, x, y)


def modular_inverse(e, z):
    """Вычисление инверсии e по модулю z. """
    gcd, x, _ = gcd_extended(e, z)
    if gcd != 1:
        raise ValueError("Инверсия не существует, e и z не взаимно простые")
    return x % z  # Возвращаем положительное значение Функция gcd_extended(e, z) может возвращать отрицательный x.
                  # Но модульная инверсия должна быть положительной, поэтому мы делаем x % z